#!/usr/bin/env bash

# Wov Test Runner


if [ "${_tr_is_loaded}" != "1" ]; then

  _tr_fold=`tput cols`
  let _tr_fold2=$_tr_fold-11
  let _tr_fold4=$_tr_fold-14

  _tr_startpath=$(realpath "`dirname $0`")

  _tr_is_loaded="1"
    # --- ensure only loaded once

  _tr_exit_on_fail=
    # --- when true, exists if a test fails

  _tr_dirs=
    # --- stack of directories it traverses

  _tr_results=
    # --- array of test results

  _tr_testson=
    # ---

  _tr_output=
    # ---

  _tr_doctest=
    # --- documentation for the next test run

  _tr_sections=
    # --- hierachy of testing sections

  _tr_tc=0

  _tr_runfile=


  # Initialization
  # ---------------------------------------------------------------------
  function tr_reset_results()
  {
    _tr_results=( 0 0 0 0 0 )    # failed passed skipped subtestfailed total
  }
  function tr_init()
  {
    tr_reset_results
    tr_onfailexit
    _tr_testson=1
    _tr_output=1
    _tr_dirs=()
    _tr_doctest=
    _tr_sections=()
    _tr_runfile="$0"
  }

  # Configuration
  # ---------------------------------------------------------------------
  function tr_onfailexit()
  {
    _tr_exit_on_fail=1
  }
  function tr_onfailcontinue()
  {
    _tr_exit_on_fail=0
  }
  function tr_tests_on()
  {
    echo ""
    echo "TESTS ON"
    _tr_testson=1
  }
  function tr_tests_off()
  {
    echo ""
    echo "TESTS OFF"
    _tr_testson=0
  }
  function tr_vverbose()
  {
    _tr_output=2
    echo ""
    echo "OUTPUT : VERYVERBOSE"
  }
  function tr_verbose()
  {
    if [ ${_tr_output} -ge 2 ]; then printf "\nOUTPUT : VERBOSE\n"; fi
    _tr_output=1
  }
  function tr_quiet()
  {
    if [ ${_tr_output} -ge 2 ]; then printf "\nOUTPUT : QUIET\n"; fi
    _tr_output=0
  }


  # Output Headings
  # ---------------------------------------------------------------------

  # $1 - if set, this is a closing section
  # $1 - separating character
  function _tr_printsection()
  {
    local SEP='>'
    if [ "$1" != "" ]; then SEP=$1; fi
    if [ ${#_tr_sections[@]} -ne 0 ]; then
      for s in "${_tr_sections[@]}"; do
        printf " ${SEP} $s"
      done
#      if [ "$1" != "" ]; then printf " / $1"; fi
      printf "\n"
    fi
  }
  function tr_section
  {
    local a=${1:0:1}
    local s=
    if [ "$a" == '/' ]; then
      s="${1:1}"
      printf "\nSECTION: "
      # printf "\n%*sSECTION: " "${#_tr_sections[@]}" ''
      tailsection=${_tr_sections[-1]}
      _tr_printsection '<'
      #printf -- "---------------------------------------------------------------------\n" 
      printf -- "-%.0s" `seq 1 ${_tr_fold}`
      printf "\n"
      if [ "${s}" != "${tailsection}" ]; then
        echo "WARNING (tr_section in $0:$BASH_LINENO): unmatched section '${s}' vs '${tailsection}'"
      fi
      unset '_tr_sections[${#_tr_sections[@]}-1]'
      if [ ${_tr_output} -ge 2 ]; then _tr_printsection $tailsection ; fi
    else
      printf "\n"
      printf -- "-%.0s" `seq 1 ${_tr_fold}`
      # printf "\n%*s\n" ${_tr_fold} '+'
      printf "\nSECTION:"
      # printf "%*sSECTION:" "${#_tr_sections[@]}" ''
      _tr_sections+=( "$1" )
      _tr_printsection
    fi

  }
  function tr_comment()
  {
    echo "COMMENT: '$1" | fold -w ${_tr_fold4} -s | gsed -e '2,$s/^/             \x27/'
  }

  function tr_h1()
  {
    echo ""
    echo ""
    echo "*********************************************************************"
    echo "${@}"
    _tr_printsection
    echo "*********************************************************************"
    echo "*********************************************************************"
  }
  function tr_h2()
  {
    echo ""
    echo "====================================================================="
    echo "${@}"
    _tr_printsection
    echo "====================================================================="
  }
  function tr_h3()
  {
    echo ""
    echo "---------------------------------------------------------------------" 
    echo "${@}"
    _tr_printsection
    echo "---------------------------------------------------------------------" 
  }
  function tr_h4()
  {
    echo ""
    echo "${@}"
    _tr_printsection
    echo "---------------------------------------------------------------------" 
  }



  # Files and Directories
  # ---------------------------------------------------------------------
  function tr_runfile()
  {
#    echo `dirname $0`
#    echo ${1}
##    echo `pwd`
#    echo `realpath ./tests/1.sh`
#    local p="`pwd`/`dirname $0`/${1}"
    local p=$(realpath "`dirname $0`/${1}")
    local spl=${#_tr_startpath}+1
    local pp="${p:spl}"
    #echo "RUN FILE '${1}' : '${p}' ${pp}"
    echo ""
    echo "RUN FILE '${pp}' ('${p}')"
    _tr_runfileold="$_tr_runfile"
    _tr_runfile="${p}"
    . "${p}"
    _tr_runfile="$_tr_runfileold"
    # TODO: should check dirs stack as it could get screwed up here
  }
  function tr_dir()
  {
    # local p=$(realpath $1)
    local p=$(pwd)
    _tr_dirs+=( "$p" )
    # printf "_tr_dirs: ${_tr_dirs[@]}"
    cd $1
    printf "\nDIR    : 'cd ${1}'\n"
  }
  function tr_popdir()
  {
    d="${_tr_dirs[-1]}"
    #printf "_tr_dirs: ${_tr_dirs[@]}"
    # printf "\nPOPDIR1: 'to $d'\n"
    unset '_tr_dirs[${#_tr_dirs[@]}-1]'
    cd $d
    printf "\nPOPDIR : 'to `pwd`'\n"
  }


  # 1 - name
  # 2 - test 
  # 3 - retval
  # 4 - num vars returned
  # * - remaining vars
  function tr_test_()
  {
    # this does not work
    _tr_tc=$((_tr_tc+1))
    tr_test "$@" &
    _tr_tctests+=( $! )
  }

  function tr_run()
  {
    if [ ${_tr_testson} == 0 ]; then tr_run_skip $1 ; return 0; fi
    >&2 printf "\nRUN    : '${1}' (${_tr_runfile}:line ${BASH_LINENO})\n"
    printf   "  CMD    : '${2}'\n"
    # TODO: capture stderr/out
    eval "${2} 2> /dev/null" | gsed 's/^/  \x27/'
  }
  function tr_run_skip()
  {
    printf "\nSKIP R : \U26A0 '${1}'\n"
  }

  function tr_test()
  {
    if [ ${_tr_testson} == 0 ]; then tr_test_skip $1 ; return 0; fi

    echo ""
    >&2 echo "TEST   : '${1}' (${_tr_runfile}:line ${BASH_LINENO})"
    if [ ${_tr_output} -ge 2 ] && [ "${_tr_doctest}" != "" ]; then printf "  DOC    : '$_tr_doctest'\n"; fi
    _tr_doctest=

    # echo "--EVAL $2"
    if [ ${_tr_output} -ge 2 ]; then
#        printf "  CMD    : '$2'\n"
        cat <<EOF | fold -w ${_tr_fold2} -s | gsed 's/^/  /'
CMD    : '$2'
EOF
    fi
    local E=()
    local EXPECTED=()
    local Re=
    local R_=
    local R=

    # R_ is raw output and has newlines
    # R is split on newlinees does not, but R maintains # of args
    # R_="$(eval ${2})"; Re=$?

    # --------------------------------------------------------------------- 
    # EVALUATE THE COMMAND
    # --------------------------------------------------------------------- 
    rm -f STDout.${_tr_tc} STDerr.${_tr_tc}
    mkfifo STDout.${_tr_tc} STDerr.${_tr_tc}
    $(COLUMNS=${_tr_fold4} eval ${2} >STDout.${_tr_tc} 2>STDerr.${_tr_tc}) &
    RP=$!
    #echo "RP ${RP}"
    exec {fdout}<STDout.${_tr_tc} {fderr}<STDerr.${_tr_tc}
    #RSTDout=$(cat <&$fdout)
    rm STDout.${_tr_tc} STDerr.${_tr_tc}
    R_=()
#    R_=($(cat <&$fdout))
    mapfile -t <&$fdout
    RM=("${MAPFILE[@]}")
    R_="${MAPFILE[@]}"
    R=("${MAPFILE[@]}")
    RSTDerr=$(cat <&$fderr)
#    echo "4 "
    wait $RP
#    echo "5 "
    Re=$?
    #echo "R_     : ${R_}"
    #echo "RSTDout: ${RSTDout}"
    #echo "RSTDerr: ${RSTDerr}"
    #echo "Re     : ${Re}"
    exec {fdout}<&- {fderr}<&-

    local R=( ${R_[@]} )
    local RR=( "${R_[@]}" )
    echo "M : ${#MAPFILE[@]} '${MAPFILE[@]}'"
    echo "RM: ${#RM[@]} '${RM[@]}'"
    echo "R_: ${#R_[@]} '${R_[@]}' ${#R_[*]} '${R_[*]}'"
    echo "R : ${#R[@]} '${R[@]}' ${#R[*]} '${R[*]}'"
    echo "RR: ${#RR[@]} '${RR[@]}' ${#RR[*]} '${RR[*]}'"
#    echo "R_: ${#R_[@]} ${#R_[*]} '${R_[@]}'"
#    echo "R : ${#R[@]} ${#R[*]} '${R[@]}'"

    # make sure it at least has some output of ''
    if [ ${#R[@]} -eq 0 ]; then R=( '' ); fi

    local retval=0
#    echo "R  '${R[@]}' '${#R[@]}' "
#    echo "Re ${Re}:${3}:${#@}"

    if [ ${#@} -lt 3 ]; then
      >&2 echo "ERROR: tr_test is missing expected return value (returned '${Re}'). Additional parameter needed for test: '${1} (line ${BASH_LINENO})'."
      exit 1
    fi

    # test retval
    if [ ${Re} != ${3} ]; then
      E+=( "F CHECK: return value '${Re}' is not '${3}'" )
      #echo "    F CHECK: return value '${Re}' is not '${3}'"
      #    let "_tr_results[3]++" # not counting return values
      retval=1
    fi

    if [ ${#@} -lt 4 ]; then
      >&2 echo "ERROR: tr_test is missing expected number of returns (returned '${#@}'). Additional parameter needed for test: '${1} (line ${BASH_LINENO})'."
      >&2 echo "  : ${R_[@]}"
      exit 1
    fi

    if [ "${4}" != "-1" ]; then
      echo "R_ ${#R_[@]}  ${#R[@]}  ${#R_[*]}  ${#R[*]}"
      if [ "${#R[@]}" != "${4}" ]; then
        E+=( "F1CHECK: returned '${#R[@]}' values but expecting ${4}. '${R_[@]}'" )
        retval=1
      fi

      # test each
      # local l="${#R[@]}"
      local l=${4}
      l="$((${l}-1))"
      #    echo "l $l"
      if [ $l -lt 0 ]; then
        >&2 echo "ERROR: test case has bad number of passed in args '$4'. Needs at least 1."
        exit 1
      fi
      for i in $(seq 0 ${l}); do
        let ii="i+5"
        # echo "- $i $ii : ${R[$i]} ${!ii}"

        # if it is a comparison (in brackets), then run it
        if [ "${!ii:0:1}" == "[" ]; then
          #        echo " ... custom test rule '${!ii}'"
          local result=${R[$i]}
          local RR=`eval ${!ii}` ; RRe=$?
          EXPECTED+=( "${!ii}" )
          #        echo "RR '${RR}' '${RRe}' : '${3}' '${4}'"
          if [ ${RRe} -eq ${3} ]; then
            let "_tr_results[4]++"
          else
            E+=( "F CHECK'${!ii}' returns '${RRe}' not '${3}'" )
            let "_tr_results[3]++"
          fi
        else
          EXPECTED+=( "${!ii}" )
          echo "R_i  .${R_[$i]}. $i"
          echo "R i  .${R[$i]}. $i"
          echo "ii .${!ii}."
          if [ "${R_[$i]}" != "${!ii}" ]; then
            E+=( "F CHECK: '${R_[$i]}' is not '${!ii}'" )
            let "_tr_results[3]++"
            retval=1
          else
            let "_tr_results[4]++"
            #      echo "  PASSED"
          fi
        fi
      done
    fi


  #  for r in "${R[@]}"
  #  do
  #    echo 
  #    if [ "${R}" != "${3}" ] || [ "${Re}" -ne ${4} ]; then
  #      echo "FAILED : '${TEST}' : ${1} : '${R}' '${Re}'"
  #      let "_tr_results[0]++"
  #    fi
  #  done



  if [ $retval -eq 1 ]; then
    #    RR="${R[@]}"
    #    printf "  FAILED '${Re}' '${RR}' is not '${3}' '"
      #    let "_tr_results[0]++"
      #    for i in $(seq 1 ${#R[@]}); do
      #      let ii="i+4"
      #      printf "${!ii}"
      #    done
      #    printf "'\n"
      printf "  EXPECT : %s\n" "${EXPECTED[@]}"
      printf "  STDOUT : '%s\n" "${R_}" | gsed -e '2,$s/^/           \x27/'
      printf "  STDERR : '%s\n" "${RSTDerr[@]}"
      #printf "  OUTPUT1: '%s\n" "${R[@]}" | fold -w ${_tr_fold4} -s | gsed -e '2,$s/^/           \x27/'
#      printf "    %s\n" "${E[@]}" | fold -w ${_tr_fold4} -s | gsed -e '2,$s/^/             \x27/'
      printf "  %s\n" "${E[@]}" | fold -w ${_tr_fold4} -s
      printf "  \U00D7 FAILED\n"
      let "_tr_results[0]++"
    else
      if [ ${_tr_output} -ge 2 ]; then
        printf "  EXPECT : %s\n" "${EXPECTED[@]}"
        printf "  STDOUT : '%s\n" "${R_[@]}" | fold -w ${_tr_fold4} -s | gsed -e '2,$s/^/           \x27/'
        if [ "${RSTDerr[@]}" != "" ]; then printf "  STDERR : '%s'\n" "${RSTDerr[@]}"; fi
      fi
      printf "  \U2713 PASSED\n"
      let "_tr_results[1]++"
    fi

    if [ ${retval} -ne 0 ] && [ ${_tr_exit_on_fail} == 1 ]; then tr_results; exit 1; fi
    return $retval
  }

  function tr_test_skip()
  {
    printf "\nSKIP T : \U26A0 '${1}'\n"
    let "_tr_results[2]++"
  }

  function tr_doctest
  {
    _tr_doctest="$*"
  }

  tr_results()
  {
    let totaltests="_tr_results[0]+_tr_results[1]+_tr_results[2]"
    let totalchecks="_tr_results[3]+_tr_results[4]"
    echo ""
    echo "RESULTS"
    echo "---------------------------------------------------------------------"
    printf "  \U00D7 Failed  : ${_tr_results[0]}  (${_tr_results[3]} checks)\n"
    printf "  \U2713 Passed  : ${_tr_results[1]}  (${_tr_results[4]} checks)\n"
    printf "  \U26A0 Skipped : ${_tr_results[2]}\n"
    printf "  Totals    : ${totaltests}  ($totalchecks checks)\n"
  }


  # Initialize it all
  tr_init
fi
